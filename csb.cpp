#include "csb.hpp"

#include <algorithm>
#include <array>
#include <cstddef>
#include <filesystem>
#include <format>
#include <string>
#include <tuple>
#include <unordered_map>
#include <utility>
#include <vector>

void csb::configure()
{
  csb::target_name = "CSGame";
  csb::target_artifact = EXECUTABLE;
  csb::target_linkage = STATIC;
  csb::target_subsystem = CONSOLE;
  csb::target_configuration = DEBUG;
  csb::cxx_standard = CXX20;
  csb::warning_level = W4;
  csb::include_files = csb::choose_files({"program/include"}, {}, {"program/include/resource.hpp"});
  csb::source_files = csb::choose_files({"program/source"}, {}, {"program/source/resource.cpp"});
  if (csb::host_platform == WINDOWS)
    csb::libraries = {"kernel32", "user32",   "shell32",  "gdi32",   "imm32",       "comdlg32",
                      "ole32",    "oleaut32", "advapi32", "dinput8", "winmm",       "winspool",
                      "setupapi", "uuid",     "version",  "cse",     "SDL3-static", "glm"};
  else if (csb::host_platform == LINUX)
    csb::libraries = {"c", "m", "pthread", "dl", "cse", "SDL3", "glm"};
}

int csb::clean()
{
  csb::clean_build();
  csb::clean({"program/include/resource.hpp", "program/source/resource.cpp"});
  return csb::build();
}

int csb::build()
{
  if (!csb::is_subproject)
    csb::clang_format("21.1.8", csb::choose_files({"program/shader"}),
                      {"program/include/resource.hpp", "program/source/resource.cpp"});

  csb::archive_install(
    {csb::host_platform == WINDOWS
       ? "https://github.com/microsoft/DirectXShaderCompiler/releases/download/v1.8.2505.1/dxc_2025_07_14.zip"
       : "https://github.com/microsoft/DirectXShaderCompiler/releases/download/v1.8.2505.1/"
         "linux_dxc_2025_07_14.x86_64.tar.gz",
     "build/dxc",
     {csb::host_platform == WINDOWS ? "bin/" + csb::host_architecture : "bin",
      csb::host_platform == WINDOWS ? "lib/" + csb::host_architecture : "lib"},
     {}});
  if (csb::host_platform == LINUX)
  {
    csb::multi_task_run("chmod +x ()",
                        csb::choose_files({"build/dxc"}, [](const auto &file) { return file.extension() == ""; }),
                        {"build/dxc/executable.(filename)"});
    csb::prepend_environment_variable("LD_LIBRARY_PATH", "build/dxc");
  }
  csb::multi_task_run(
    [](const std::filesystem::path &file, const auto &, const auto &) -> std::string
    {
      return std::format("{} -spirv -T {}_6_0 -E main () -Fo []",
                         csb::host_platform == WINDOWS ? "build\\dxc\\dxc.exe" : "./build/dxc/dxc",
                         file.extension() == ".vert" ? "vs" : "ps");
    },
    csb::choose_files({"program/shader"}), {"build/shader/(filename).spv"});

  using animation_name = std::string;
  using animation_range = std::pair<unsigned int, unsigned int>;
  using animation_times = std::vector<double>;
  using hitbox_name = std::string;
  using hitbox_bounds = std::array<double, 4>;
  using animation_hitboxes = std::vector<std::unordered_map<hitbox_name, hitbox_bounds>>;
  using animations = std::vector<std::tuple<animation_name, animation_range, animation_times, animation_hitboxes>>;
  using frame_dimensions = std::pair<unsigned int, unsigned int>;
  using frame_data = std::pair<frame_dimensions, animations>;
  std::unordered_map<std::filesystem::path, frame_data> frame_map{};
  for (const auto &object : csb::read_file<nlohmann::json>("program/texture/frames.json"))
  {
    const auto &file{object["file"].get<std::filesystem::path>()};
    const auto &dimensions{object["frame_dimensions"].get<frame_dimensions>()};
    animations animations{};
    for (const auto &animation : object["animations"])
      animations.emplace_back(animation["name"].get<animation_name>(), animation["range"].get<animation_range>(),
                              animation["times"].get<animation_times>(),
                              animation.contains("hitboxes") ? animation["hitboxes"].get<animation_hitboxes>()
                                                             : animation_hitboxes{});
    frame_map.emplace(file, frame_data{dimensions, animations});
  }

  bool vertex_defined{};
  bool fragment_defined{};
  using binary_data = std::vector<std::byte>;
  using width = unsigned int;
  using height = unsigned int;
  using channels = unsigned int;
  using image_data = std::tuple<width, height, channels>;
  using texture_data = std::tuple<image_data, frame_data>;
  using resource = std::tuple<binary_data, texture_data>;
  csb::embed<resource>(
    {"// This file is automatically generated, do not edit manually.\n\n"
     "#pragma once\n\n"
     "#include \"cse/hitbox.hpp\"\n"
     "#include \"cse/resource.hpp\"\n\n"
     "namespace csg\n"
     "{\n",
     "// This file is automatically generated, do not edit manually.\n\n"
     "#include \"resource.hpp\"\n\n"
     "#include <array>\n"
     "#include <utility>\n\n"
     "#include \"cse/hitbox.hpp\"\n"
     "#include \"cse/resource.hpp\"\n\n"
     "namespace csg\n"
     "{\n"},
    {[&vertex_defined, &fragment_defined](const std::filesystem::path &file, const std::string &name,
                                          const resource &data) -> std::string
     {
       std::string result{};
       if (file.extension() == ".spv")
       {
         std::string extension{};
         if (file.stem().extension() == ".vert")
         {
           extension = "vertex";
           if (!vertex_defined)
           {
             result += "  namespace vertex\n  {\n";
             vertex_defined = true;
           }
         }
         else if (file.stem().extension() == ".frag")
         {
           extension = "fragment";
           if (!fragment_defined)
           {
             result += "  }\n  namespace fragment\n  {\n";
             fragment_defined = true;
           }
         }
         result += std::format("    extern const cse::{} {};\n", extension, name);
       }
       else
       {
         if (fragment_defined)
         {
           result += "  }\n";
           fragment_defined = false;
         }
         result += "  namespace image\n  {\n";
         result += std::format("    extern const cse::image {};\n", name);
         result += "  }\n";

         const auto &[binary_data, texture_data]{data};
         const auto &[image_data, frame_data]{texture_data};
         const auto &[frame_dimensions, animations]{frame_data};
         result += "  namespace animation\n  {\n";
         result += "    namespace detail\n    {\n";
         result += std::format("      struct {}_animation\n      {{\n", name);
         for (const auto &animation : animations)
         {
           const auto &[animation_name, animation_range, animation_times, animation_hitboxes]{animation};
           result += std::format("        const cse::animation {};\n", animation_name);
         }
         result += "      };\n";
         result += "    }\n";
         result += std::format("    extern const detail::{}_animation {};\n", name, name);
         result += "  }\n";

         std::vector<std::string> hitbox_names{};
         for (const auto &animation : animations)
         {
           const auto &[animation_name, animation_range, animation_times, animation_hitboxes]{animation};
           for (const auto &hitbox : animation_hitboxes)
             for (const auto &[identifier, bounds] : hitbox)
               if (std::find(hitbox_names.begin(), hitbox_names.end(), identifier) == hitbox_names.end())
                 hitbox_names.push_back(identifier);
         }
         if (!hitbox_names.empty())
         {
           result += "  namespace hitbox\n  {\n";
           result += "    namespace detail\n    {\n";
           result += std::format("      struct {}_hitbox\n      {{\n", name);
           for (const auto &hitbox_name : hitbox_names)
             result += std::format("        const cse::hitbox {};\n", hitbox_name);
           result += "      };\n";
           result += "    }\n";
           result += std::format("    extern const detail::{}_hitbox {};\n", name, name);
           result += "  }\n";
         }
       }
       return result;
     },
     [](const std::filesystem::path &file, const std::string &name, const resource &) -> std::string
     {
       if (file.extension() == ".spv")
       {
         std::string extension{};
         if (file.stem().extension() == ".vert")
           extension = "vertex";
         else
           extension = "fragment";
         return std::format("  static constexpr std::array<const unsigned char, (1)> {}_{}_data{{\n    (0)}};\n\n",
                            name, extension);
       }
       else
         return std::format(
           "  static constexpr std::array<const unsigned char, (1)> {}_texture_image{{\n    (0)}};\n(2)\n\n", name);
     },
     [](const std::filesystem::path &file) -> std::string
     {
       if (file.extension() == ".spv")
         return file.stem().stem().string();
       else
         return file.stem().string();
     },
     [&frame_map](const std::filesystem::path &file) -> resource
     {
       if (file.extension() == ".spv")
         return {csb::read_file<binary_data>(file), {}};
       else
       {
         stbi_set_flip_vertically_on_load(true);
         auto image{csb::read_file<csb::image>(file)};
         const auto &[frame_dimensions, animations]{frame_map.at(file.filename())};
         return {image.data, {{image.width, image.height, image.channels}, {frame_dimensions, animations}}};
       }
     },
     [](const std::string &name, const resource &data) -> std::vector<std::string>
     {
       std::vector<std::string> results{};
       const auto &[binary_data, texture_data]{data};
       std::string binary_data_result{};
       for (std::size_t index{}; index < binary_data.size(); ++index)
       {
         binary_data_result += csb::byte_to_hex(binary_data[index]);
         if (index < binary_data.size() - 1)
         {
           binary_data_result += ",";
           if ((index + 1) % 16 == 0)
             binary_data_result += "\n    ";
           else
             binary_data_result += " ";
         }
       }
       results.push_back(binary_data_result);
       results.push_back(std::to_string(binary_data.size()));

       const auto &[image_data, frame_data]{texture_data};
       const auto &[width, height, channels]{image_data};
       const auto &[frame_dimensions, animations]{frame_data};
       const auto &[frame_width, frame_height]{frame_dimensions};
       if (width == 0 || height == 0 || channels == 0 || frame_width == 0 || frame_height == 0 || animations.empty())
         return results;
       const unsigned int frames_per_row{width / frame_width};
       const unsigned int frames_per_column{height / frame_height};
       std::string animations_result{};

       for (const auto &animation : animations)
       {
         const auto &[animation_name, animation_range, animation_times, animation_hitboxes]{animation};
         const auto &[start_frame, end_frame]{animation_range};
         std::size_t frame_count{};
         for (unsigned int frame_index{start_frame - 1}; frame_index < end_frame; ++frame_index)
         {
           if (frame_count < animation_hitboxes.size() && !animation_hitboxes[frame_count].empty())
           {
             const auto &frame_hitboxes{animation_hitboxes[frame_count]};
             animations_result +=
               std::format("  static constexpr std::array<const std::pair<cse::hitbox, cse::rectangle>, {}> "
                           "{}_texture_{}_frame_{}_hitboxes\n  {{\n    {{",
                           frame_hitboxes.size(), name, animation_name, frame_count + 1);
             std::size_t hitbox_index{};
             for (const auto &[hitbox_name, hitbox_bounds] : frame_hitboxes)
             {
               animations_result +=
                 std::format("{{cse::hitbox(\"{}\"), {{{:#g}, {:#g}, {:#g}, {:#g}}}}}", name + "." + hitbox_name,
                             hitbox_bounds[0], hitbox_bounds[1], hitbox_bounds[2], hitbox_bounds[3]);
               if (hitbox_index < frame_hitboxes.size() - 1) animations_result += ",\n     ";
               ++hitbox_index;
             }
             animations_result += "}\n  };\n";
           }
           ++frame_count;
         }

         animations_result += std::format("  static constexpr std::array<const cse::animation::frame, "
                                          "{}> {}_texture_{}_frames\n  {{\n    {{",
                                          end_frame - start_frame + 1, name, animation_name);
         frame_count = 0;
         for (unsigned int frame_index{start_frame - 1}; frame_index < end_frame; ++frame_index)
         {
           const unsigned int frame_x{frame_index % frames_per_row};
           const unsigned int frame_y{(frames_per_column - 1) - (frame_index / frames_per_row)};
           const float top{static_cast<float>((frame_y + 1) * frame_height) / static_cast<float>(height)};
           const float left{static_cast<float>(frame_x * frame_width) / static_cast<float>(width)};
           const float bottom{static_cast<float>(frame_y * frame_height) / static_cast<float>(height)};
           const float right{static_cast<float>((frame_x + 1) * frame_width) / static_cast<float>(width)};
           bool has_hitboxes{frame_count < animation_hitboxes.size() && !animation_hitboxes[frame_count].empty()};
           if (has_hitboxes)
             animations_result +=
               std::format("{{{{{:#g}, {:#g}, {:#g}, {:#g}}}, {:#g}, {}_texture_{}_frame_{}_hitboxes}}", left, top,
                           right, bottom, animation_times.at(frame_count), name, animation_name, frame_count + 1);
           else
             animations_result += std::format("{{{{{:#g}, {:#g}, {:#g}, {:#g}}}, {:#g}}}", left, top, right, bottom,
                                              animation_times.at(frame_count));
           if (frame_index < end_frame - 1) animations_result += ",\n     ";
           ++frame_count;
         }
         animations_result += "}\n  };";
         if (&animation != &animations.back()) animations_result += "\n";
       }
       results.push_back(animations_result);
       return results;
     }},
    {[](const std::vector<std::tuple<std::filesystem::path, std::string, resource>> &) -> std::string { return "}"; },
     [&vertex_defined, &fragment_defined](
       const std::vector<std::tuple<std::filesystem::path, std::string, resource>> &files) -> std::string
     {
       std::string result{};
       vertex_defined = false;
       fragment_defined = false;
       for (const auto &[file, name, data] : files)
       {
         if (!vertex_defined && file.stem().extension() == ".vert")
         {
           result += "  namespace vertex\n  {\n";
           vertex_defined = true;
         }
         else if (!fragment_defined && file.stem().extension() == ".frag")
         {
           result += "  }\n  namespace fragment\n  {\n";
           fragment_defined = true;
         }
         if (file.extension() == ".spv")
         {
           std::string extension{};
           if (file.stem().extension() == ".vert")
             extension = "vertex";
           else
             extension = "fragment";
           result += std::format("    const cse::{} {}{{{}_{}_data}};\n", extension, name, name, extension);
         }
         else
         {
           if (fragment_defined)
           {
             result += "  }\n";
             fragment_defined = false;
           }
           const auto &[image_data, frame_data]{std::get<1>(data)};
           const auto &[width, height, channels]{image_data};
           const auto &[frame_dimensions, animations]{frame_data};
           const auto &[frame_width, frame_height]{frame_dimensions};
           result += "  namespace image\n  {\n";
           result += std::format("    const cse::image {}{{{}_texture_image, {}, {}, {}, {}, {}}};\n", name, name,
                                 width, height, frame_width, frame_height, channels);
           result += "  }\n";
           result += "  namespace animation\n  {\n";
           result += std::format("    const detail::{}_animation {}\n    {{\n      ", name, name);
           for (const auto &animation : animations)
           {
             const auto &[animation_name, animation_range, animation_times, animation_hitboxes]{animation};
             const auto &[start_frame, end_frame]{animation_range};
             result += std::format("{{{}_texture_{}_frames, {}, {}}}", name, animation_name, start_frame, end_frame);
             if (&animation != &animations.back()) result += ",\n      ";
           }
           result += "\n    };\n";
           result += "  }\n";
           std::vector<std::string> hitbox_names{};
           for (const auto &animation : animations)
           {
             const auto &[animation_name, animation_range, animation_times, animation_hitboxes]{animation};
             for (const auto &hitbox : animation_hitboxes)
               for (const auto &[identifier, bounds] : hitbox)
                 if (std::find(hitbox_names.begin(), hitbox_names.end(), identifier) == hitbox_names.end())
                   hitbox_names.push_back(identifier);
           }
           if (!hitbox_names.empty())
           {
             result += "  namespace hitbox\n  {\n";
             result += std::format("    const detail::{}_hitbox {}\n    {{\n      ", name, name);
             for (std::size_t i{}; i < hitbox_names.size(); ++i)
             {
               result += std::format("cse::hitbox(\"{}\")", name + "." + hitbox_names[i]);
               if (i < hitbox_names.size() - 1) result += ",\n      ";
             }
             result += "\n    };\n";
             result += "  }\n";
           }
         }
       }
       return result + "}";
     }},
    [](const std::filesystem::path &file) -> bool { return file.extension() == ".spv" || file.extension() == ".png"; },
    csb::combine(
      {csb::choose_files({"build/shader"}, [](const auto &file) { return file.stem().extension() == ".vert"; }),
       csb::choose_files({"build/shader"}, [](const auto &file) { return file.stem().extension() == ".frag"; }),
       csb::choose_files({"program/texture"})}),
    {"program/include/resource.hpp", "program/source/resource.cpp"});

  csb::subproject_install({"ConnorSweeneyDev/CSEngine", "0.0.0", COMPILED_LIBRARY});

  csb::generate_compile_commands();
  csb::compile();
  csb::link();
  return csb::run();
}

int csb::run()
{
  csb::run_target();
  return csb::success;
}

CSB_MAIN()
